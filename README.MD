# QA-DevOps-Practical - 'Meal roulette' App:  
This Github contains my files for my github

## Contents:
* [Project Requirements](#Project-Requirements)
* [Project Planning](#Project-Planning)
* [Meal roulette app](#The-App)
* [Testing](#Testing)
* [CI CD Pipeline](#CI-CD-Pipeline)
* [Challenges and Known Issues](#Challenges)
* [Conslusion and changes in future ](#Future-Work)

## Project Requirements:

The brief that was assigned was to create an application that generates "objects" based upon a predefine rules.
* Service 1: The main service which will render templates used to interact with the application, this will be responsible for communicating with the services.
* Service 2: Generate a random object which will be used with the object generated from service 3, these will both be based on to generate an object for service 4.
* Service 3: Same objective as service 2.
* Service 4: Generate a final object, this will be determined based on the values generated by service 3 & 4.

### Constraints overview:
The tools I will use for each of the constraints are listed below:

* Kanban board: Trello
* Version Control: Git (GitHub) 
* CI server: Jenkins
* Configuration Manager: Ansible
* Cloud server: GCP virtual machines
* Containerisation: Docker
* Orchestration Tool: Docker Swarm
* Reverse Proxy: NGINX

## Project Planning:  
I used a trello board to keep track off all the tasks needed to completed to create, run and build the app. The initial trello board is below:




## The App
The application I have chosen to build is an meal roulette generator.
The purpose of this application is to choose a random breakfast from a specific list I made and choose a random lunch meal from another list I made.
  
The application uses a microservice architecture, explained below:
* Service 1 - Front-End: This is where the user interacts with the web page and displays all the services combined

* Service 2 - breakfast API: GET request that generates a random breakfast meal

* Service 3 - lunch: GET request that generates a random lunch meal

* Service 4 - calories: Post requests which displays service 1 and adds up the calories off both the breakfast and lunch meals.

Altogether the appication will generate them a random breakfast meal and lunch and will tell the user the calories off both meals combined. 

![Main image](https://github.com/Abdulbutt786/QA-project2/blob/e107eab3bfc11741f5756231888dee417807a04d/images/Mainpage2.png)

This shows a picture off my main and only screen you can see it generates the random breakfast and lunch and the calories off both meals together. As you refresh the page it will generate new set off information. 

This is another picture once a refresh has been done and shows need info has been printed: 

![Main](https://github.com/Abdulbutt786/QA-project2/blob/6a4e281a39b12e2baaa21d0b1dc698c5bb4cf040/images/Mainpage.png)



Below is the risk assessment for the SFIA2 application. The full risk assessment can be viewed here: https://docs.google.com/spreadsheets/d/1sRQDBjGwsqQNldhdVXTh3Z9JooZ77M9lWruPBY74Pes/edit?usp=sharing

![Risk Assessment](https://github.com/Abdulbutt786/QA-project2/blob/81eafc86dad3959b2da915704978bc61e320a81f/images/risk%20assesment.png)

I have created a risk which would highlight the risks I would face when creating the application and how I would action a solution in order to resolve them. These will help me from mitigating the threats to my application to better the security in order to get it deployed as quickly and safely as possible with no bugs.

# Testing

Unit testing is used to verify that individual aspects of the app function correctly. This was a control measured realised before starting the project this was marked as priority to ensure the user has the correct use of the app.

The pictures below show the jenkins automated unit tests off each service which I have achieved 100% coverage. The command used in order to print these results to the terminal is : 

* python3 -m pytest --cov --cov-report xml -v

In addition you can use:

* python3 -m pytest --cov --cov-report term-missing

This command will check if theres any part off the code your missing that you havent tested. Fortunately, I have achieved 100% on every service.



![Coverage1](https://github.com/Abdulbutt786/QA-project2/blob/81eafc86dad3959b2da915704978bc61e320a81f/images/service1.png)
![Coverage2](https://github.com/Abdulbutt786/QA-project2/blob/81eafc86dad3959b2da915704978bc61e320a81f/images/serrvice2.png)
![Coverage3](https://github.com/Abdulbutt786/QA-project2/blob/81eafc86dad3959b2da915704978bc61e320a81f/images/service3.png)
![Coverage2](https://github.com/Abdulbutt786/QA-project2/blob/81eafc86dad3959b2da915704978bc61e320a81f/images/service4.png)

The project is now set up to automatically conduct tests via Jenkins every time a push is made to the GitHub repository. These tests can be seen running in the console output of the Jenkins job each time the build is run.

# CI Pipeline

For my github repository I used the feature branch model and then merge them into one. I created a feature off all service and once the tests for each were completed they were merged. 

You can see the feature branches below:

![Feature](https://github.com/Abdulbutt786/QA-project2/blob/19bbc1c07d0204afbc3602b0fa29685fffb880b3/images/Branches.png)

Jenkins was used as a build server in order to automate the tests, the various build steps and deployment. This is achieved by creating a pipeline project via Jenkins, the project uses Anisble and Docker Swarm to deploy the application. A webhook is used to continuously integrate changes whenever a commit is pushed to the GitHub Repository.  

Below I will show you the pipeline process that jenkins conducts: 

![Jenks](https://github.com/Abdulbutt786/QA-project2/blob/19bbc1c07d0204afbc3602b0fa29685fffb880b3/images/Jenkins%20build.png)

As I said a webhook is set up so as soon a push is made to my dev branch - jenkins will automatically start the automation off the pipeline.

Pipeline process:

1. Runs unit tests for each of the 4 services
2. Runs the Ansible playbook, which installs relevant docker packages (See below images for further explanation)
3. Building and pushing images to dockerhub with my credentials
4. Copies the docker-compose.yaml file and the nginx.conf file to the Docker swarm manager VM and deploys the application from there

Once the jenkins pipeline is complete. It roughly takes about 5 minutes, once complete, we will able to go the IP addresses on our GCP of the docker swarm manager and worker and access the website. 

This picture below shows the CI/CD Pipline:

![Jenks pipline](https://github.com/Abdulbutt786/QA-project2/blob/19bbc1c07d0204afbc3602b0fa29685fffb880b3/images/Pipline.png)

# Challenges

I faced many issues especially with jenkins this is the reason I was had over 120 jenkins builds for my projects. However, these errors were different errors all the time and most simple to fix. This gave me alot off experience with troubleshooting in general. 

In addition, to this the unit testing was quite different from the first result as we had to mock in results to our website which was something i hadn't done before. 

# Future-Work

In conclusion, this project was uch different to the first one as the focus was primarily on using all the automation and build tools. I love to make the website to make more aesthetic pleasing and maybe even make a homepage before to this current page I have. 